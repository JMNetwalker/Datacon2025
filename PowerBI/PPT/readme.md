# üìä Power BI, DirectQuery and SQL Server ‚Äì Is It a Good Choice?

This session explores the real-world performance implications of using **Power BI with DirectQuery against SQL Server** (especially Azure SQL Database Hyperscale). It walks through a series of complex reporting scenarios, identifies common performance issues, and applies advanced optimization techniques.

---

## üéØ Session Objectives

- Understand how Power BI translates visuals into SQL queries.
- Learn to analyze query performance using **Query Store**.
- Explore best practices for optimizing reports based on large datasets.
- Demonstrate how to fix real performance problems using:
  - Indexed Views
  - Clustered Columnstore Indexes
  - Table Partitioning
  - Join/filter indexing
  - Execution plan tuning

---

## üß™ Environment

- **SQL Engine:** Azure SQL Database ‚Äì Hyperscale Gen5 (4 vCores)
- **Databases:** `PowerBIHyperScaleDemo` and `PowerBIHyperScaleDemo_V1`
- **Fact Table:** `Fact.Sale` with 235 million rows
- **Dimension Tables:** Date, City, Stock Item, Employee, etc.

---

## üìà Reporting Scenarios & Optimizations

### 1. Reporting by Fiscal Month
- **Initial Time:** 4 minutes  
- **Fix:** Indexed View ‚Üí ‚è±Ô∏è 0 seconds

### 2. Reporting by Fiscal Month and City
- **Initial Time:** 4 minutes  
- **Fix:** Indexed View ‚Üí ‚è±Ô∏è 15 seconds

### 3. Reporting by Fiscal Month, Stock, and Filtering by Month
- **Initial Time:** 4 minutes  
- **Fix:** Partitioning + Columnstore Index ‚Üí ‚è±Ô∏è 3 seconds

### 4. Reporting by Fiscal Month and Employee (with filter)
- **Initial Time:** 4 minutes  
- **Fix:** Partitioning + Columnstore Index ‚Üí ‚è±Ô∏è 20 seconds

### 5. Reporting by Total Sales (Count) ‚Äì Global
- **Initial Time:** High and inconsistent  
- **Fix:** Columnstore Index ‚Üí ‚è±Ô∏è Reduced by 10x

---

## üîç Troubleshooting Workflow

1. Capture the query generated by Power BI.
2. Use **Query Data Store (QDS)** to analyze:
   - Query duration
   - Reads
   - CPU time
3. Review execution plans:
   - Look for scans, hash joins, and bottlenecks.
4. Apply fixes:
   - Indexed Views (with `SCHEMABINDING`)
   - Columnstore Indexes
   - Partitioning (on `DeliveryDateKey` or similar)
   - Supporting indexes on join keys

---

## üß† Best Practices

- **Avoid runtime aggregations** ‚Üí Pre-aggregate via indexed views
- **Use SCHEMABINDING** to enable indexed views
- **Index join/filter keys** to improve optimizer decisions
- **Columnstore Indexes** are ideal for large fact tables
- **Partitioning** enhances performance and manageability

---

## ‚úÖ Conclusions

- Power BI with DirectQuery can perform well **if** the backend SQL schema is optimized.
- Schema design, indexing, and partitioning are essential.
- Hyperscale with Gen5 (4 vCores) supports large-scale workloads.
- Use Query Store to drive tuning decisions with real metrics.

---

## üë®‚Äçüè´ Speakers

### Jos√© Manuel Jurado D√≠az (Microsoft)
- Escalation Engineer, PaaS Database Team
- Speaker at SQLBits, TechReady, Azure Global BootCamp, and more  
- Twitter: [@jmJuradoDiaz](https://twitter.com/jmJuradoDiaz)

### Juan Moreno Romo (Microsoft)
- Support Escalation Engineer, SQL Core Team  
- HA SME, developer and architect background  
- Twitter: [@DarthSicuel](https://twitter.com/DarthSicuel)
